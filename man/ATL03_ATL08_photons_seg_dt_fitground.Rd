% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ATL03_ATL08_photons_seg_dt_fitground.R
\name{ATL03_ATL08_photons_seg_dt_fitground}
\alias{ATL03_ATL08_photons_seg_dt_fitground}
\title{Fit and estimate ground elevation for photons or arbitrary distances
from the track beginning.}
\usage{
ATL03_ATL08_photons_seg_dt_fitground(
  atl03_atl08_seg_dt,
  smoothing_window = NA,
  smoothing_func = median,
  interpolation_func = NA,
  xout_parameter_name = "xout",
  ...
)
}
\arguments{
\item{atl03_atl08_seg_dt}{An S4 object of class \code{\linkS4class{icesat2.atl03_atl08_seg_dt}} containing ATL03 and ATL08 data
(output of \code{\link[=ATL03_ATL08_photons_attributes_dt_join]{ATL03_ATL08_photons_attributes_dt_join()}} function).}

\item{smoothing_window}{numeric. The smoothing window size in meters for smoothing the photon cloud.
Default is NA, see details for more information.}

\item{smoothing_func}{function. The smoothing function to be applied on the smoothing window.}

\item{interpolation_func}{function. The interpolation function to estimate the ground elevation.}

\item{xout_parameter_name}{character. Optional, can be used to inform the parameter name that the
interpolation_func uses for passing the prediction vector and already use the photons for prediction.
Default NA will use the ...}

\item{...}{Optional parameters to pass to the interpolation_func, see details for more information.}
}
\description{
Function to estimate ground elevation using smoothing and
interpolation functions
}
\details{
The function for calculating the ground will first pass a smoothing
window with \code{smoothing_window} size,
applying the \code{smoothing_func} to aggregate the ground photons.

Then it will use an interpolation function between those
aggregated photons to calculate a smooth surface.

The \code{smoothing_func} signature will depend on the function used.
It is assumed that the first two arguments are vectors of \code{x} (independent
variable) and \code{y} (the prediction to be interpolated). The remaining
arguments are passed through \code{...}.

The interpolation functions need a third parameter which is the
\code{x} vector to be interpolated. Functions from \code{stats} base package
\code{stats::approx()} and \code{stats::spline()} name this argument as \code{xout},
so you can use:

\if{html}{\out{<div class="sourceCode">}}\preformatted{ATL03_ATL08_photons_seg_dt_fitground(
  dt,
  interpolation_func = approx,
  xout = 1:30
)
}\if{html}{\out{</div>}}

For example, to interpolate the values for the 1:30 vector. But other functions
may name the parameter differently, such as \code{\link[signal:pchip]{signal::pchip()}}, which name
the parameter as \code{xi} instead of \code{xout}. \code{\link[signal:pchip]{signal::pchip()}} is the
algorithm used by ATL08 ATBD.

If you don't want to specify the vector to interpolate, but instead get the
predictions for every photon then instead specify the parameter name used by
the interpolation function in \code{xout_parameter_name}:

\if{html}{\out{<div class="sourceCode">}}\preformatted{ATL03_ATL08_photons_seg_dt_fitground(
  dt,
  interpolation_func = signal::pchip,
  xout_parameter_name = "xi"
)
}\if{html}{\out{</div>}}

The \code{smoothing_window} can be left NA, which will use the ATBD algoritm
for calculating the window size:

$Sspan = ceil\link{5 + 46 * (1 - e^{-a * length})}$, where \emph{length}
is the number of photons within segment.

$$a \approx 21x10^{-6}$$

$$window_size = \frac{2}{3} Sspan$$
}
